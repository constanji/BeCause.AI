# 知识库自动存储说明

## 当前存储方式

### 现状：支持两种存储方式

1. **手动存储**（已实现）- 通过 API 端点手动添加
2. **自动存储**（已实现）- 从对话中自动提取 QA 对

## 存储方式详解

### 方式1: 手动存储（API 调用）

通过调用 API 端点手动添加知识条目。

#### API 端点

- **单个添加**: `POST /api/rag/knowledge`
- **批量添加**: `POST /api/rag/knowledge/batch`

#### 使用示例

```javascript
// 添加QA对
fetch('/api/rag/knowledge', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Authorization': 'Bearer YOUR_JWT_TOKEN'
  },
  body: JSON.stringify({
    type: 'qa_pair',
    data: {
      question: '什么是RAG？',
      answer: 'RAG是检索增强生成技术'
    }
  })
});
```

### 方式2: 自动存储（对话后提取）

系统会在 AI 回复消息保存后，自动分析用户问题和 AI 回答，提取为 QA 对并存储到知识库。

#### 工作流程

```
用户发送消息
    ↓
AI 生成回复
    ↓
保存 AI 消息到数据库
    ↓
触发 MessageKnowledgeHook
    ↓
检查是否适合提取为 QA 对
    ↓
检查是否已存在相似 QA（去重）
    ↓
生成向量嵌入
    ↓
存储到 MongoDB + PostgreSQL
```

#### 自动提取规则

系统会自动提取满足以下条件的对话：

1. **用户消息**:
   - 包含问号（`?` 或 `？`）
   - 或包含疑问词（什么、如何、怎么、为什么、能否等）
   - 或消息长度 < 200 字符（短消息更可能是问题）

2. **AI 回复**:
   - 长度 > 20 字符（有实际内容）
   - 不是"抱歉"、"我不确定"等无法回答的情况

3. **去重检查**:
   - 检查知识库中是否已存在相似度 ≥ 0.8 的 QA 对
   - 如果存在，跳过提取（避免重复）

## 配置

### 环境变量

在 `.env` 文件中配置：

```env
# 启用自动提取知识（默认：false，需要手动启用）
AUTO_EXTRACT_KNOWLEDGE=true

# 自动提取的相似度阈值（默认：0.8）
# 如果知识库中已存在相似度 >= 此值的QA对，则跳过提取
AUTO_EXTRACT_MIN_SCORE=0.8

# 启用向量数据库（默认：true）
USE_VECTOR_DB=true
```

### 启用自动存储

1. **设置环境变量**:
   ```env
   AUTO_EXTRACT_KNOWLEDGE=true
   ```

2. **重启服务**:
   ```bash
   docker-compose restart api
   ```

3. **验证**:
   - 进行一次对话
   - 检查日志中是否有 `[AutoKnowledgeExtractor] 自动提取并存储QA对` 的日志
   - 或调用 `GET /api/rag/knowledge` 查看是否有新的 QA 对

## 自动提取示例

### 示例对话

**用户**: "什么是向量数据库？"

**AI**: "向量数据库是专门用于存储和检索高维向量的数据库系统。它使用向量相似度搜索来找到最相关的数据。"

**结果**: 系统自动提取并存储为 QA 对：

```json
{
  "type": "qa_pair",
  "question": "什么是向量数据库？",
  "answer": "向量数据库是专门用于存储和检索高维向量的数据库系统。它使用向量相似度搜索来找到最相关的数据。"
}
```

### 不会提取的情况

1. **用户消息不是问题**:
   - "帮我写一段代码" ❌
   - "帮我写一段代码？" ✅

2. **AI 无法回答**:
   - AI: "抱歉，我不确定这个问题的答案" ❌

3. **已存在相似 QA**:
   - 如果知识库中已有相似度 ≥ 0.8 的 QA 对，跳过提取

## 存储位置

### MongoDB

- **集合**: `knowledgeentries`
- **存储内容**: 完整的知识条目，包括向量、元数据等

### PostgreSQL + pgvector

- **表**: `knowledge_vectors`
- **存储内容**: 向量和基本元数据，用于高效相似度搜索

## 性能考虑

### 异步处理

- 知识提取是**异步执行**的，不会阻塞消息保存
- 使用 `setImmediate` 在下一个事件循环中执行
- 即使提取失败，也不会影响消息保存

### 去重机制

- 每次提取前会检查是否已存在相似的 QA 对
- 避免存储重复的知识条目
- 减少存储空间和检索噪音

## 监控和日志

### 日志位置

自动提取的日志会出现在：

```
[AutoKnowledgeExtractor] 自动提取并存储QA对: { question: "..." }
[MessageKnowledgeHook] 已触发知识提取任务
```

### 查看提取的知识

```bash
# 通过 API 查看
curl -X GET "http://localhost:4080/api/rag/knowledge?type=qa_pair" \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

## 手动管理

### 查看所有知识条目

```bash
GET /api/rag/knowledge?type=qa_pair&limit=100
```

### 删除知识条目

```bash
DELETE /api/rag/knowledge/:id
```

### 批量导入

```bash
POST /api/rag/knowledge/batch
{
  "entries": [
    { "type": "qa_pair", "question": "...", "answer": "..." },
    { "type": "synonym", "noun": "...", "synonyms": [...] }
  ]
}
```

## 未来扩展

### 计划中的功能

1. **智能分析**: 使用 LLM 分析对话，提取多种类型的知识
2. **用户确认**: 自动提取的知识需要用户确认后再存储
3. **批量提取**: 从历史对话中批量提取知识
4. **知识分类**: 自动分类提取的知识（技术、业务、FAQ等）

### 扩展点

可以在以下位置扩展自动提取功能：

- `api/server/services/RAG/AutoKnowledgeExtractor.js` - 提取逻辑
- `api/server/services/RAG/MessageKnowledgeHook.js` - 触发时机
- `api/models/Message.js` - 消息保存钩子

## 相关文件

- **自动提取服务**: `api/server/services/RAG/AutoKnowledgeExtractor.js`
- **消息钩子**: `api/server/services/RAG/MessageKnowledgeHook.js`
- **消息模型**: `api/models/Message.js` (saveMessage 函数)
- **API 端点**: `api/server/routes/rag.js`
- **控制器**: `api/server/controllers/RAGController.js`

## 总结

- ✅ **手动存储**: 已实现，通过 API 端点
- ✅ **自动存储**: 已实现，对话后自动提取 QA 对
- ⚙️ **配置**: 通过 `AUTO_EXTRACT_KNOWLEDGE` 环境变量控制
- 🔄 **异步处理**: 不阻塞消息保存流程
- 🚫 **去重机制**: 自动检查重复，避免存储重复知识

