# 工具加载机制对比：Claude 客户端 vs 本项目 Agent

本文档对比 Claude 客户端的 Skill 扫描机制和本项目的 Agent 工具加载机制。

---

## 零、当前项目的工具调用形式（Function Calling 1.0 时代）

### 当前实现：传统 Function Calling 1.0 标准形态

本项目**完全符合**最传统的 Tool 加载方式（Function Calling 1.0 时代），采用 OpenAI function calling / LangChain / early Agent 的标准形态。

### 传统流程（本项目当前形态）

```text
应用启动
  ↓
开发者手动定义所有 tools（硬编码在 toolConstructors 对象中）
  ↓
Agent 初始化时，根据 Agent.tools 配置加载工具
  ↓
从 toolConstructors 获取工具类并实例化
  ↓
提取 name、schema、description 构建工具定义
  ↓
把 tools 的 schema 一次性传给 LLM（通过 agentContext.getToolsForBinding()）
  ↓
LLM 在对话中选择是否调用
  ↓
运行时执行对应函数（通过 ToolNode.runTool()）
```

### 具体实现细节

#### 1. **工具硬编码注册**（`api/app/clients/tools/util/handleTools.js`）

```javascript
const toolConstructors = {
  flux: FluxAPI,
  calculator: Calculator,
  google: GoogleSearchAPI,
  open_weather: OpenWeather,
  wolfram: StructuredWolfram,
  'stable-diffusion': StructuredSD,
  'azure-ai-search': StructuredACS,
  traversaal_search: TraversaalSearch,
  tavily_search_results_json: TavilySearchResults,
  speckit: Speckit,
  because: BeCause,  // ← 硬编码注册
  database_schema: DatabaseSchema,
  social: SocialMedia,
  bazi_astrology: BaziAstrology,
  sql_executor: SqlExecutor,
  semantic_model_generator: SemanticModelGenerator,
};
```

**特点**：
- ✅ 所有工具在代码中硬编码
- ✅ 类型安全，IDE 支持完整
- ❌ 添加新工具需要修改代码并重启服务

#### 2. **工具类定义**（继承 LangChain Tool）

每个工具是一个 JavaScript 类，继承自 `@langchain/core/tools` 的 `Tool`：

```javascript
// api/app/clients/tools/structured/BeCause.js
class BeCause extends Tool {
  name = 'because';
  description = '智能问数（自然语言转SQL）提示词模板系统...';
  schema = z.object({
    command: z.enum([...]),
    arguments: z.string().optional(),
    mode: z.enum(['default', 'agentic']).optional(),
  });
  
  async _call(args) {
    // 执行逻辑
  }
}
```

**特点**：
- ✅ 使用 Zod schema 定义参数结构（类型安全）
- ✅ `name`、`description`、`schema` 直接定义在类中
- ✅ 完整的执行逻辑在 `_call` 方法中

#### 3. **Agent 配置驱动**（`api/server/services/ToolService.js`）

Agent 配置中有 `tools` 数组，指定要使用的工具：

```javascript
// Agent 配置示例
{
  id: 'agent-123',
  tools: ['because', 'database_schema', 'sql_executor'],  // ← 工具列表
  // ...
}
```

在 `loadAgentTools` 函数中：
```javascript
const { loadedTools, toolContextMap } = await loadTools({
  agent,
  tools: _agentTools,  // ← 从 Agent 配置中获取工具列表
  // ...
});

// 构建工具定义
const toolDefinition = {
  name: tool.name,
  schema: tool.schema,
  description: tool.description,
};
```

#### 4. **一次性传给 LLM**（`agents-because/src/graphs/Graph.ts`）

在 `createCallModel` 中，所有工具定义一次性绑定到模型：

```javascript
const toolsForBinding = agentContext.getToolsForBinding();
let model = this.initializeModel({
  tools: toolsForBinding,  // ← 一次性传入所有工具
  provider: agentContext.provider,
  clientOptions: agentContext.clientOptions,
});
```

**特点**：
- ✅ 所有工具的 schema 在对话开始时就传给 LLM
- ✅ LLM 可以看到所有可用工具
- ❌ 工具数量多时，会占用大量 context tokens

#### 5. **运行时执行**（`agents-because/src/tools/ToolNode.ts`）

当 LLM 决定调用工具时：

```javascript
protected async runTool(call: ToolCall, config: RunnableConfig) {
  const tool = this.toolMap.get(call.name);  // ← 从 toolMap 获取工具实例
  const output = await tool.invoke(invokeParams, config);  // ← 执行工具
  return new ToolMessage({
    status: 'success',
    name: tool.name,
    content: typeof output === 'string' ? output : JSON.stringify(output),
    tool_call_id: call.id!,
  });
}
```

### 总结：完全符合 Function Calling 1.0 标准

| 特性 | 传统 Function Calling 1.0 | 本项目实现 |
|------|---------------------------|-----------|
| **工具定义方式** | 手动定义所有 tools | ✅ 硬编码在 `toolConstructors` |
| **Schema 传递** | 一次性传给 LLM | ✅ 通过 `getToolsForBinding()` 一次性传入 |
| **工具选择** | LLM 在对话中选择 | ✅ LLM 根据 schema 选择调用 |
| **执行时机** | 运行时执行对应函数 | ✅ 通过 `ToolNode.runTool()` 执行 |
| **类型安全** | 通常使用 JSON Schema | ✅ 使用 Zod schema（更类型安全） |
| **动态发现** | ❌ 不支持 | ❌ 不支持（需要硬编码） |
| **热加载** | ❌ 需要重启 | ❌ 需要重启 |

**结论**：本项目**完全采用**传统的 Function Calling 1.0 方式，是标准的静态工具注册 + 一次性 schema 传递 + 运行时执行的模式。

---

## 一、Claude 客户端的 Skill 扫描机制

### 流程

1. **启动时自动扫描**
   - 客户端启动时自动扫描所有 `skills/` 目录

2. **读取 SKILL.md 文件**
   - 对每个 skill 的 `SKILL.md` 文件，**只读取 frontmatter 部分**（两个 `---` 之间的 YAML）

3. **解析元数据**
   - 解析 `name` 和 `description` 字段
   - 建立索引表

4. **不读取 body 部分**
   - `---` 之后的内容（Markdown body）不会被读取
   - 只有在实际使用 skill 时才读取完整内容

### 示例

```yaml
---
name: user-authentication
description: 用户认证和授权功能
---

# User Authentication Skill

这里是详细说明，不会被扫描时读取...
```

**扫描结果**：
- `name`: `user-authentication`
- `description`: `用户认证和授权功能`
- Body 部分：不读取

### 特点

- ✅ **自动发现**：启动时自动扫描目录
- ✅ **轻量级**：只读取 frontmatter，不读取完整文件
- ✅ **快速索引**：建立 name 和 description 的索引表
- ✅ **按需加载**：实际使用时才读取完整内容

---

## 二、本项目的 Agent 工具加载机制

### 流程

1. **硬编码注册**
   - 工具在代码中**硬编码注册**，不扫描目录
   - 位置：`api/app/clients/tools/util/handleTools.js`

```javascript
const toolConstructors = {
  flux: FluxAPI,
  calculator: Calculator,
  google: GoogleSearchAPI,
  open_weather: OpenWeather,
  wolfram: StructuredWolfram,
  'stable-diffusion': StructuredSD,
  'azure-ai-search': StructuredACS,
  traversaal_search: TraversaalSearch,
  tavily_search_results_json: TavilySearchResults,
  speckit: Speckit,
  because: BeCause,  // ← BeCause 工具硬编码注册
  database_schema: DatabaseSchema,
  social: SocialMedia,
  bazi_astrology: BaziAstrology,
  sql_executor: SqlExecutor,
  semantic_model_generator: SemanticModelGenerator,
};
```

2. **工具类定义**
   - 每个工具是一个 JavaScript 类，继承自 `Tool`
   - `name` 和 `description` 直接在类中定义
   - 位置：`api/app/clients/tools/structured/BeCause.js`

```javascript
class BeCause extends Tool {
  name = 'because';

  description =
    '智能问数（自然语言转SQL）提示词模板系统。' +
    'Commands: sql-generation (生成SQL), sql-generation-reasoning (生成推理计划), ' +
    'intent-classification (意图分类), data-assistance (数据辅助), misleading-assistance (误导查询处理), ' +
    'scoring (文档评分), hypothetical-questions (假设问题生成), agentic/main-agent (Agentic主代理), ' +
    'agentic/text-to-sql (Agentic文本转SQL), agentic/data-assistance (Agentic数据辅助), ' +
    'agentic/misleading-assistance (Agentic误导查询处理)。';

  schema = z.object({
    command: z.enum([...]),
    arguments: z.string().optional(),
    mode: z.enum(['default', 'agentic']).optional(),
  });
}
```

3. **Agent 配置驱动**
   - Agent 配置中有 `tools` 数组，指定要使用的工具
   - 根据配置从 `toolConstructors` 中加载对应的工具类

4. **运行时实例化**
   - 当 Agent 需要使用时，实例化工具类
   - 工具类中包含完整的逻辑

### 特点

- ✅ **静态注册**：工具在代码中硬编码，类型安全
- ✅ **类型定义**：使用 Zod schema 定义参数结构
- ✅ **完整逻辑**：工具类包含完整的执行逻辑
- ❌ **不自动发现**：需要手动在代码中注册新工具
- ❌ **需要重启**：添加新工具需要修改代码并重启服务

---

## 三、详细对比

| 特性 | Claude 客户端（Skill） | 本项目（Agent 工具） |
|------|----------------------|-------------------|
| **发现方式** | 启动时自动扫描目录 | 代码中硬编码注册 |
| **元数据来源** | SKILL.md 的 frontmatter（YAML） | 工具类的 `name` 和 `description` 属性 |
| **读取内容** | 只读取 frontmatter，不读 body | 加载完整的工具类代码 |
| **索引建立** | 建立 name 和 description 索引表 | 通过 toolConstructors 对象映射 |
| **添加新工具** | 添加 SKILL.md 文件即可（热加载） | 需要修改代码并注册（需重启） |
| **工具定义** | Markdown 文件（frontmatter + body） | JavaScript 类（继承 Tool） |
| **参数定义** | 可能在 frontmatter 中 | Zod schema（类型安全） |
| **执行逻辑** | Body 部分或 scripts/ 目录 | 工具类的方法 |
| **运行时加载** | 实际使用时读取完整内容 | 实例化工具类 |

---

## 四、本项目的工具加载流程

### 1. 应用启动时（`api/server/services/Config/app.js`）

```javascript
const loadBaseConfig = async () => {
  const systemTools = loadAndFormatTools({
    adminFilter: config.filteredTools,
    adminIncluded: config.includedTools,
    directory: paths.structuredTools,  // api/app/clients/tools/structured
  });
  return AppService({ config, paths, systemTools });
};
```

**说明**：
- 扫描 `api/app/clients/tools/structured/` 目录
- 加载所有 `.js` 文件作为工具类
- 但这只是为了系统工具注册，不是 Agent 工具的主要加载方式

### 2. Agent 初始化时（`api/server/services/ToolService.js`）

```javascript
async function loadAgentTools({ req, res, agent, signal, tool_resources, openAIApiKey }) {
  // ...
  const { loadedTools, toolContextMap } = await loadTools({
    user: req.user.id,
    agent,
    tools: agent.tools,  // ← 从 Agent 配置中获取工具列表
    // ...
  });
  
  // 构建工具定义
  const toolDefinition = {
    name: tool.name,
    schema: tool.schema,
    description: tool.description,
  };
}
```

**说明**：
- Agent 配置中有 `tools` 数组（如：`['because', 'database_schema']`）
- 从 `toolConstructors` 对象中获取对应的工具类
- 实例化工具类，提取 `name`、`schema`、`description`

### 3. 工具调用时（运行时）

```javascript
// Agent 调用工具
await agent.callTool('because', {
  command: 'sql-generation',
  arguments: '查询每个国家的病例总数'
});

// 工具执行
const toolInstance = new BeCause({ projectRoot: process.cwd() });
const result = await toolInstance._call({ command: 'sql-generation', arguments: '...' });
```

**说明**：
- Agent 根据工具名调用对应的工具类
- 工具类执行具体逻辑（读取模板、返回指令等）

---

## 五、关键区别总结

### Claude 客户端（Skill）

```
启动时扫描
    ↓
读取 SKILL.md frontmatter
    ↓
解析 name 和 description
    ↓
建立索引表
    ↓
[用户使用 skill]
    ↓
读取完整的 SKILL.md 或 scripts/
```

**优势**：
- 自动发现，无需修改代码
- 轻量级扫描，快速启动
- 热加载，添加新 skill 无需重启

### 本项目（Agent 工具）

```
应用启动
    ↓
加载工具类（从目录或硬编码）
    ↓
Agent 初始化
    ↓
根据 Agent.tools 配置加载工具
    ↓
从 toolConstructors 获取工具类
    ↓
实例化工具类（name, schema, description）
    ↓
[Agent 调用工具]
    ↓
执行工具类的逻辑
```

**优势**：
- 类型安全（Zod schema）
- 完整的 IDE 支持
- 代码即文档
- 易于调试

**劣势**：
- 需要修改代码添加新工具
- 需要重启服务
- 不能动态发现

---

## 六、对应关系

| Claude 客户端 | 本项目 |
|--------------|--------|
| `skills/` 目录 | `api/app/clients/tools/structured/` 目录 |
| `SKILL.md` 文件 | `BeCause.js` 工具类文件 |
| Frontmatter 的 `name` | 工具类的 `name` 属性 |
| Frontmatter 的 `description` | 工具类的 `description` 属性 |
| Body 部分（详细说明） | 工具类的方法和逻辑 |
| `scripts/` 目录（可执行代码） | 工具类的 `_call` 方法 |
| 启动时扫描目录 | 硬编码在 `toolConstructors` 中 |
| 索引表 | `toolConstructors` 对象 |

---

## 七、如果要在本项目实现类似 Skill 的扫描机制

如果要实现类似 Claude 客户端的自动扫描机制，需要：

1. **扫描 `.because/commands/` 目录**
   - 读取所有 `.md` 文件
   - 解析 frontmatter（如果有）

2. **解析命令信息**
   - 从命令模板中提取 `name` 和 `description`
   - 建立索引表

3. **动态注册工具**
   - 根据扫描结果动态创建工具类
   - 注册到 `toolConstructors`

4. **按需加载模板**
   - 实际调用时才加载命令模板和提示词模板

**但当前实现**：
- 使用硬编码注册更简单直接
- 类型安全，易于维护
- 适合需要稳定性的生产环境

---

## 总结

**Claude 客户端（Skill）**：
- 扫描目录 → 读取 frontmatter → 建立索引 → 按需加载

**本项目（Agent 工具）**：
- 硬编码注册 → 工具类定义 → Agent 配置 → 运行时实例化

两者设计理念不同：
- **Claude**：动态发现，灵活扩展
- **本项目**：静态注册，类型安全，稳定可靠

---

